<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Qstudy的博客</title>
    <link>http://qstudy.tech/post/</link>
    <description>Recent content in Posts on Qstudy的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 26 Nov 2021 23:27:26 +0800</lastBuildDate><atom:link href="http://qstudy.tech/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>First_beego</title>
      <link>http://qstudy.tech/2021/11/26/</link>
      <pubDate>Fri, 26 Nov 2021 23:27:26 +0800</pubDate>
      
      <guid>http://qstudy.tech/2021/11/26/</guid>
      <description>使用beego创建api项目，实现增删改查，简单记录 1.mac安装beego和bee工具 1 2 go get -u github.com/beego/beego/v2 go get -u github.com/beego/bee/v2 如果需要bee设置为全局变量，添加zshrc全局alias，在~/.zshrc中编辑添加alias bee=xxx/bee beego官方文档 2.使用bee工具创建项目 1 bee api app_delivery -conn=&amp;#34;root:root****@tcp(127.0.0.1:3306)/test-beego 创建后orm.Re</description>
    </item>
    
    <item>
      <title>关于择偶</title>
      <link>http://qstudy.tech/2021/10/10/</link>
      <pubDate>Sun, 10 Oct 2021 10:52:04 +0800</pubDate>
      
      <guid>http://qstudy.tech/2021/10/10/</guid>
      <description>找什么样的人？有个文案感觉说的很有道理 其实，给你倒水，半夜给你买烧烤，这些都不是稀有的物种。 而现实是，有些人却偏偏为这种低成本的付出感动的死去活来！ 真正的稀缺资源，是对方的谈吐，对方的知识面，对方的视野，对方控制局面的能力，对方的情绪稳定！ 不要小看上面的这些特点，要培养这些优点，</description>
    </item>
    
    <item>
      <title>移除链表元素</title>
      <link>http://qstudy.tech/2021/06/05/</link>
      <pubDate>Sat, 05 Jun 2021 23:29:36 +0800</pubDate>
      
      <guid>http://qstudy.tech/2021/06/05/</guid>
      <description>题目: 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点，具体见链接 LeetCode-203 相关代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import &amp;#34;fmt&amp;#34; type ListNode struct { Val int Next *ListNode } //crete linklist func CreateNode(node *ListNode, max int) { cur := node for i := 1; i &amp;lt; max; i++ {</description>
    </item>
    
    <item>
      <title>Nginx日志统计</title>
      <link>http://qstudy.tech/2021/04/08/</link>
      <pubDate>Thu, 08 Apr 2021 15:16:44 +0800</pubDate>
      
      <guid>http://qstudy.tech/2021/04/08/</guid>
      <description>是一个比较简单的脚本用来nginx的access日志简单处理，主要实现以下三个功能： 统计几分钟之内，请求最多的前几个ip（默认是3分钟，前10个ip） 统计几分钟之内，请求最多的接口(默认是3分钟，前10个接口) 统计前几ip，分别请求的前几个接口 具体脚本下： 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    
    <item>
      <title>Fibonacci</title>
      <link>http://qstudy.tech/post/fibonacci/</link>
      <pubDate>Sun, 04 Apr 2021 23:28:44 +0800</pubDate>
      
      <guid>http://qstudy.tech/post/fibonacci/</guid>
      <description>斐波那契数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import &amp;#34;fmt&amp;#34; //动态规划 func fib(n int) int { if n &amp;lt; 2 { return n } nums := make([]int, n) nums[0], nums[1] = 1, 1 for i := 2; i &amp;lt; n; i++ { // nums[i] = (nums[i-1] + nums[i-2]) % 1000000007 nums[i] = nums[i-1] + nums[i-2] } return nums[n-1] } //递归 func fib01(n int) int { if n &amp;lt; 2 { return n } return fib01(n-1) + fib01(n-2) } func main() { var n int fmt.Scanln(&amp;amp;n) fmt.Println(fib(n)) fmt.Println(&amp;#34;the fib01 is &amp;#34;, fib01(n)) }</description>
    </item>
    
    <item>
      <title>2021应该开个好头</title>
      <link>http://qstudy.tech/2021/01/22/</link>
      <pubDate>Fri, 22 Jan 2021 21:39:03 +0800</pubDate>
      
      <guid>http://qstudy.tech/2021/01/22/</guid>
      <description>菜是原罪 2021来了 不知不觉2021年的第一个月，已经快要结束了， 划水的日子固然很爽，慌却是非常地真实的 &amp;hellip;&amp;hellip; 北漂or回家？ 不知道接下来是否继续北漂， 还是回老家？ 好多事情想了不止一遍， 都悬在空中， 一动不动； 去， 还是 留 其实我也到现在也还没有想明白， 去了之后呢？ 留下来呢？ &amp;hellip; 问题的核心好像</description>
    </item>
    
    <item>
      <title>Mytest</title>
      <link>http://qstudy.tech/2021/01/08/</link>
      <pubDate>Fri, 08 Jan 2021 01:08:22 +0800</pubDate>
      
      <guid>http://qstudy.tech/2021/01/08/</guid>
      <description>this my test zhege ge zhende sh markdown练习 插入代码 1 2 3 4 package main func main(){ fmt.Println(&amp;#34;hello world&amp;#34;) } hello word ###插入图片</description>
    </item>
    
    <item>
      <title>再来学习一下tcp</title>
      <link>http://qstudy.tech/archives/221/</link>
      <pubDate>Sat, 02 May 2020 10:48:57 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/221/</guid>
      <description>为什么要再次学习tcp 其实很多时候，说不知道好像也知道，说知道也说不出所以然，貌似都是死记硬背这些东西，然后有个印象，理解不够透彻，今天再来温习一下大学里面学过的tcp，顺便记录一下，其实了解了整个过程，可能问题也就比较清楚了 下面这些问题，是不是经常遇到？ tcp三次握手，四次挥手</description>
    </item>
    
    <item>
      <title>HTTP状态码</title>
      <link>http://qstudy.tech/archives/213/</link>
      <pubDate>Sat, 21 Dec 2019 03:10:58 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/213/</guid>
      <description>面试经常会被问道了解http状态码吗？你知道301和302什么区别，401和403什么区别，502和503什么区别？ HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–49</description>
    </item>
    
    <item>
      <title>linux系统进程状态有哪些？</title>
      <link>http://qstudy.tech/archives/210/</link>
      <pubDate>Mon, 18 Nov 2019 15:47:07 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/210/</guid>
      <description>进程状态有哪些？ 在学校的操作系统原理中，我们系统中的进程有多种状态，那对应到常用的linux系统，有哪些进程状态呢？通过top可看到有以下的状态： R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。 D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterrupti</description>
    </item>
    
    <item>
      <title>理解平均负载和CPU使用率</title>
      <link>http://qstudy.tech/archives/209/</link>
      <pubDate>Sun, 17 Nov 2019 03:00:00 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/209/</guid>
      <description>平均负载 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。 使用uptime命令，依次是过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average; 理解平均负载， 比如当平均负载为 2 时，意味着什么呢？ 在只有 2 个 CPU 的系统上，意</description>
    </item>
    
    <item>
      <title>理解Linux中的buffer和cache</title>
      <link>http://qstudy.tech/archives/208/</link>
      <pubDate>Sat, 16 Nov 2019 11:12:14 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/208/</guid>
      <description>磁盘和文件的区别： 关于磁盘和文件的区别，本来以为大家都懂了，所以没有细讲。磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。 其实 Linux 中“一切皆文件”，而文章中提到的“文件”是普通文件，磁盘是块设备文件，这些大家可以执行</description>
    </item>
    
    <item>
      <title>golang中的map</title>
      <link>http://qstudy.tech/archives/207/</link>
      <pubDate>Sat, 16 Nov 2019 06:09:14 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/207/</guid>
      <description>golang中map学习 哈希表 哈希表是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value； golang中的map 在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V</description>
    </item>
    
    <item>
      <title>WordPress搬家</title>
      <link>http://qstudy.tech/archives/177/</link>
      <pubDate>Thu, 07 Nov 2019 03:13:45 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/177/</guid>
      <description>WordPress搬家 主要采坑过程如下： 复制之前的php目录到目标新机器 在新机器上面安装openresty(nginx), apt install php7.2-fpm php7.2-mysql php7.2-curl php7.2-json php7.2-mbstring php7.2-xml php7.2-intl,安装php服务 apt-get install mysql-server 安装数据库 查看php服务，service php7.2-fpm status 目录下/etc/php/7.2/fpm/pool.d，</description>
    </item>
    
    <item>
      <title>go解决leetcode-242</title>
      <link>http://qstudy.tech/archives/168/</link>
      <pubDate>Sun, 04 Aug 2019 02:32:44 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/168/</guid>
      <description>解决思路：使用map来解决问题； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func isAnagram(s string, t string) bool { // var m1 map[string]int // var m2 map[string]int //map申明后默认是nil，得用make进行实例化 m1 := make(map[string]int) m2 := make(map[string]int) for _, i := range s { m1[string(i)]++ } for _, j := range t { m2[string(j)]++ } return reflect.DeepEqual(m1, m2) //map不能直接用“==”进行比</description>
    </item>
    
    <item>
      <title>git常用操作</title>
      <link>http://qstudy.tech/archives/162/</link>
      <pubDate>Wed, 08 May 2019 15:43:50 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/162/</guid>
      <description>1、git使用的常规操作 git pull——&amp;gt;编辑——&amp;gt;git add——&amp;gt;git commit——&amp;gt;git push 用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支； 用git push 提交到远</description>
    </item>
    
    <item>
      <title>第一次参与github开源教程</title>
      <link>http://qstudy.tech/archives/161/</link>
      <pubDate>Wed, 08 May 2019 15:40:02 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/161/</guid>
      <description>参照https://github.com/Dlgde/first-contributions/blob/master/translations/README.chs.md</description>
    </item>
    
    <item>
      <title>go实现单链表反转</title>
      <link>http://qstudy.tech/archives/157/</link>
      <pubDate>Wed, 24 Apr 2019 14:54:59 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/157/</guid>
      <description>单链表核心代码如下： 1.迭代方法： 1 2 3 4 5 6 7 8 func reverseList(node *ListNode) *ListNode { cur := node var pre *ListNode for cur != nil { cur.Next, pre, cur = pre, cur, cur.Next } return pre } 理解：cur指向当前节点，pre是前节点初始为nil，反转过程： 1 2 3 4 next := cur.next //新建一个临时节点用于保存cur.next，不然会丢失 cur.next = pre pre = cur cur = next 2.递归方式 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>go实现选择排序</title>
      <link>http://qstudy.tech/archives/155/</link>
      <pubDate>Mon, 22 Apr 2019 15:33:23 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/155/</guid>
      <description>选择排序：对于给定的一组记录，经过第一轮比较之后得到最小记录，然后将该记录与第一个记录的位置进行交换；接着对对不包括第一个记录以外的其他记录进行第二轮比较，得到的最小记录与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个为止。 具体实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13</description>
    </item>
    
    <item>
      <title>go实现简单的客户端-服务器应用</title>
      <link>http://qstudy.tech/archives/154/</link>
      <pubDate>Sat, 20 Apr 2019 07:14:09 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/154/</guid>
      <description>&lt;h4 id=&#34;一个web服务器应用需要响应众多客户端的并发请求go会为每一个客户端产生一个协程用来处理请求&#34;&gt;一个（web）服务器应用需要响应众多客户端的并发请求：go会为每一个客户端产生一个协程用来处理请求&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;知识点：goroute，net包，socket&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go语言中使用defer、panic、recover处理异常</title>
      <link>http://qstudy.tech/archives/152/</link>
      <pubDate>Fri, 19 Apr 2019 14:59:56 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/152/</guid>
      <description>go语言中的异常处理，没有try&amp;hellip;catch等，而是使用defer、panic、recover来处理异常。 知识点：defer、panic、recover，异常处理 1、首先，panic 是用来表示非常严重的不可恢复的错误的。在Go语言中这是一个内置函数，如果在程序中遇到</description>
    </item>
    
    <item>
      <title>goroute应用-模拟远程调用RPC</title>
      <link>http://qstudy.tech/archives/150/</link>
      <pubDate>Fri, 19 Apr 2019 14:08:51 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/150/</guid>
      <description>在本例中，使用通道代替socket实现RPC过程，客户端和服务器运行在同一个进程，服务器和客户端在两个goroute中。 应用知识：goroute，select，RPC过程 1、客户端请求和接收封装 下面的代码封装了向服务器请求数据，等待服务器返回数据，如果请求方超时，利用select</description>
    </item>
    
    <item>
      <title>goroute之间通信-共享全局变量(理解go的多并发)</title>
      <link>http://qstudy.tech/archives/139/</link>
      <pubDate>Fri, 05 Apr 2019 02:20:30 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/139/</guid>
      <description>1、go语言中goroute之间通信有两种方式： 通过全局变量，这种方式得加锁 通过channel进行通信 下面是一个通过全局变量进行通信的例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) var ( m = make(map[int]uint64) lock sync.Mutex ) type task struct { n int } func calc(t *task) { var</description>
    </item>
    
    <item>
      <title>go语言变量逃逸(Escape Analysis)</title>
      <link>http://qstudy.tech/archives/85/</link>
      <pubDate>Tue, 26 Mar 2019 08:06:56 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/85/</guid>
      <description>&lt;h4 id=&#34;自动决定变量分配在栈还是堆escape-analysis&#34;&gt;自动决定变量分配在栈还是堆——Escape Analysis&lt;/h4&gt;</description>
    </item>
    
    <item>
      <title>接口应用-可扩展输出方式的日志系统</title>
      <link>http://qstudy.tech/archives/83/</link>
      <pubDate>Mon, 25 Mar 2019 15:40:56 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/83/</guid>
      <description>利用接口实现一个可扩展的日志系统： 1、日志对外接口： 本例中定义一个日志写入的接口(LogerWriter),要求写入设备必须遵守这个接口协议(实现这个接口)才能被日志器(Logger)注册。日志器有ResgisterWriter()和Log()两个方法，ResgisterWrit</description>
    </item>
    
    <item>
      <title>go语言实现通用链表</title>
      <link>http://qstudy.tech/archives/81/</link>
      <pubDate>Sun, 24 Mar 2019 18:43:15 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/81/</guid>
      <description>实现通用链表 link.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package main import &amp;#34;fmt&amp;#34; type LinkNode struct { data interface{} next *LinkNode } type Link struct { head *LinkNode tail *LinkNode } func (p *Link) InsertHead(data interface{}) { node := &amp;amp;LinkNode{ data: data, next: nil, } if p.tail == nil &amp;amp;&amp;amp; p.head == nil { p.head = node p.tail = node return } node.next = p.head p.head = node } func (p *Link) InsertTail(data interface{}) { node := &amp;amp;LinkNode{ data:</description>
    </item>
    
    <item>
      <title>go语言接口实现应用-Sort接口</title>
      <link>http://qstudy.tech/archives/58/</link>
      <pubDate>Sat, 23 Mar 2019 15:25:09 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/58/</guid>
      <description>&lt;h4 id=&#34;go语言接口&#34;&gt;go语言接口：&lt;/h4&gt;
&lt;p&gt;go语言的接口设计是非侵入式的，接口的编写者无需知道接口被那些类型实现。而接口实现者只需要知道实现的是什么样子的接口，但无须指明实现哪一个接口。不像其他语言需要用implement来指出实现了哪个接口。有几个需要注意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;interface本身也是一种类型，可以定义一组方法，但是接口中不能包含任何的变量&lt;/li&gt;
&lt;li&gt;必须实现了接口中的所有方法，才能调用接口&lt;/li&gt;
&lt;li&gt;实现接口的方法必须和接口中定义的方法格式一致，包括函数名和返回值等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;多态&#34;&gt;&lt;strong&gt;多态&lt;/strong&gt;：&lt;/h4&gt;
&lt;p&gt;一种的事物的多种形态，都可以按照统一的接口进行操作。&lt;/p&gt;
&lt;p&gt;理解：比如go语言sort包中提供了一个排序的Sort接口，它可以对整数，浮点数，字符串等进行排序，只要实现接口中定义的下面三个方法，就可以调用Sort方法进行排序，不用每一种类型都去定义一种实现的方法。&lt;/p&gt;
&lt;p&gt;我们从go网站上面可以查到Sort方法是这样：func Sort（data Interface）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;type&lt;/span&gt; Interface &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Len is the number of elements in the collection.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Len 为集合内元素的总数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;Len&lt;/span&gt;() &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Less reports whether the element with
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// index i should sort before the element with index j.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Less 返回索引为 i 的元素是否应排在索引为 j 的元素之前。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;Less&lt;/span&gt;(i, j &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;bool&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Swap swaps the elements with indexes i and j.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Swap 交换索引为 i 和 j 的元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;Swap&lt;/span&gt;(i, j &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>hello,go</title>
      <link>http://qstudy.tech/archives/38/</link>
      <pubDate>Thu, 21 Mar 2019 14:22:00 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/38/</guid>
      <description>hello,go</description>
    </item>
    
    <item>
      <title>生活，如此多娇</title>
      <link>http://qstudy.tech/archives/33/</link>
      <pubDate>Thu, 21 Mar 2019 14:00:02 +0000</pubDate>
      
      <guid>http://qstudy.tech/archives/33/</guid>
      <description>学会不低头，过去已经属于过去，把握当前，未来可期！</description>
    </item>
    
  </channel>
</rss>
